---
title: Homework 7 - Creating a resume database
author: (Nathan Townsend)
date: 11/11/2023
format:
    html:
        theme: cosmo
        toc: true
        embed-resources: true
        code-copy: true
---

(include a brief description of what is in this document)



GITHUB URL:  <https://github.com/cmsc-vcu/cmsc508-fa2023-hw7-NateTownsend26/edit/main/hw7/hw7.qmd>

```{python}
#| eval: true
#| echo: false
import os
import sys
import pandas as pd
from tabulate import tabulate
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from sqlalchemy.exc import OperationalError, ProgrammingError
from IPython.display import display, Markdown
```
```{python}
#| eval: true
#| echo: false

# modify config_map to reflect credentials needed by this program
config_map = {
    'user':'CMSC508_USER',
    'password':'CMSC508_PASSWORD',
    'host':'CMSC508_HOST',
    'database':'HW7_DB_NAME'
}
# load and store credentials
load_dotenv()
config = {}
for key in config_map.keys():
    config[key] = os.getenv(config_map[key])
flag = False
for param in config.keys():
    if config[param] is None:
        flag = True
        print(f"Missing {config_map[param]} in .env file")
#if flag:
#    sys.exit(1)
```
```{python}
#| eval: true
#| echo: false

# build a sqlalchemy engine string
engine_uri = f"mysql+pymysql://{config['user']}:{config['password']}@{config['host']}/{config['database']}"

# create a database connection.  THIS IS THE ACTUAL CONNECTION!
try:
    cnx = create_engine(engine_uri)
except ArgumentError as e:
    print(f"create_engine: Argument Error: {e}")
    #sys.exit(1)
except NoSuchModuleError as e:
    print(f"create_engine: No Such Module Error: {e}")
    #sys.exit(1)
except Exception as e:
    print(f"create_engine: An error occurred: {e}")
    #sys.exit(1)
```
```{python}
#| echo: false
#| eval: true

# Do a quick test of the connection and trap the errors better!
try:
    databases = pd.read_sql("show databases",cnx)
except ImportError as e:
    print(f"Error: {e}")
except OperationalError as e:
    print(f"Database/SQL Error:\n{str(e)}\n")
except ProgrammingError as e:
    print(f"Programming Error:\n{str(e)}\n")
except Exception as e:
    print(f"An error occurred:\n{str(e)}\n")

```

## Overview and description

The primary goal of this assignment is to showcase a high level of proficiency in SQL by undertaking tasks involving the creation, population, and querying of a relational database.

The structured database encompasses tables designed to store information about individuals (people), their respective skills (skills), the various roles they might undertake (roles), and the specific skills attributed to each person (peopleskills). Additionally, a table is dedicated to mapping individuals to their corresponding roles (peopleroles).

Each table serves a distinct purpose within the database, contributing to a comprehensive representation of the data. The provided sample queries in the documentation serve as practical illustrations of how to extract valuable insights from this dataset. Examples include identifying all individuals with a particular skill or role, compiling a list of unused skills, and pinpointing individuals lacking any registered skills. These queries are specifically formulated for execution in a Jupyter notebook environment, leveraging Python for seamless connectivity and interaction with the MySQL database.

## Crows-foot diagram

(add a description of the diagram and what the reader is seeing.)

```{mermaid}
%%| echo: false
erDiagram
    CUSTOMER ||--o{ ORDER : places
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses
    CUSTOMER{
        int id
        string first_name
        string last_name
    }
    DELIVERY-ADDRESS {
        int id
    }
```

## Examples of data in the database

For the people, skills, and roles tables, provide a description of each table and it's contents. Then provide a listing of the entire table.

### People table

The *people* table contains elements that describe ... 

Below is a list of data in the *people* table.

```{python}
#| echo: false
#| eval: true
sql = f"""
select * from people;
"""
## Add code to list roles table here
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df
```

### Skills table

The *skills* table contains elements that describe ... 

Below is a list of data in the *skills* table.

```{python}
#| echo: false
#| eval: true

## Add code to list roles table here
```

### Roles table

The *roles* table contains elements that describe ... 

Below is a list of data in the *roles* table.

```{python}
#| echo: false
#| eval: true

## Add code to list roles table here
```


## Sample queries

Let's explore the database!

# List skill names, tags, and descriptions ordered by name

(here a sample query)

```{python}
sql = f"""
select * from people
"""
```


(and here is a sample result from the query)

```{python}
#| echo: false
#| eval: true
try:
    df = pd.read_sql(sql,cnx)
    df
except Exception as e:
    message = str(e)
    print(f"An error occurred:\n\n{message}\n\nIgnoring and moving on.")
    df = pd.DataFrame()
df

```


### List people names and email addresses ordered by last_name


### List skill names of Person 1


### List people names with Skill 6


### List people with a DEVELOPER role


### List names and email addresses of people without skills


### List names and tags of unused skills


### List people names and skill names with the BOSS role


### List ids and names of unused roles


## Reflection

Embarking on this database assignment has proven to be an illuminating exploration into the pragmatic application of relational database theory. It facilitated a hands-on journey that effectively bridged the gap between abstract concepts and the practical intricacies of real-world database design. Through the meticulous construction of a database schema, the establishment of relationships, and the creative population of tables, I acquired a profound comprehension of how fundamental database normalization principles form the bedrock of efficient data organization. The assignment emphasized the significance of precision in naming conventions and the foresight essential for planning scalability. The manual assignment of IDs to specific tables before transitioning to auto-increment highlighted the evolution from manual control to database-managed processes. Moreover, the imperative to consider NULL handling prompted critical contemplation regarding the nature of data and its representation. In its entirety, this assignment provided a clear trajectory into what database administration entails, offering a narrative on the meticulous care and strategic thinking that underlies the development of robust data management systems.

